// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
  Int8,
} from "@graphprotocol/graph-ts";

export class Player extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Player entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Player must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Player", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Player | null {
    return changetype<Player | null>(
      store.get_in_block("Player", id.toHexString()),
    );
  }

  static load(id: Bytes): Player | null {
    return changetype<Player | null>(store.get("Player", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get heroes(): HeroLoader {
    return new HeroLoader(
      "Player",
      this.get("id")!.toBytes().toHexString(),
      "heroes",
    );
  }

  get relics(): RelicLoader {
    return new RelicLoader(
      "Player",
      this.get("id")!.toBytes().toHexString(),
      "relics",
    );
  }

  get parties(): PartyLoader {
    return new PartyLoader(
      "Player",
      this.get("id")!.toBytes().toHexString(),
      "parties",
    );
  }

  get profile(): Bytes | null {
    let value = this.get("profile");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set profile(value: Bytes | null) {
    if (!value) {
      this.unset("profile");
    } else {
      this.set("profile", Value.fromBytes(<Bytes>value));
    }
  }

  get vip(): Bytes | null {
    let value = this.get("vip");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set vip(value: Bytes | null) {
    if (!value) {
      this.unset("vip");
    } else {
      this.set("vip", Value.fromBytes(<Bytes>value));
    }
  }

  get vault(): Bytes | null {
    let value = this.get("vault");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set vault(value: Bytes | null) {
    if (!value) {
      this.unset("vault");
    } else {
      this.set("vault", Value.fromBytes(<Bytes>value));
    }
  }
}

export class Hero extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Hero entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Hero must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Hero", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Hero | null {
    return changetype<Hero | null>(store.get_in_block("Hero", id));
  }

  static load(id: string): Hero | null {
    return changetype<Hero | null>(store.get("Hero", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get power(): BigInt {
    let value = this.get("power");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set power(value: BigInt) {
    this.set("power", Value.fromBigInt(value));
  }

  get rarity(): i32 {
    let value = this.get("rarity");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set rarity(value: i32) {
    this.set("rarity", Value.fromI32(value));
  }

  get party(): string | null {
    let value = this.get("party");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set party(value: string | null) {
    if (!value) {
      this.unset("party");
    } else {
      this.set("party", Value.fromString(<string>value));
    }
  }
}

export class Relic extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Relic entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Relic must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Relic", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Relic | null {
    return changetype<Relic | null>(store.get_in_block("Relic", id));
  }

  static load(id: string): Relic | null {
    return changetype<Relic | null>(store.get("Relic", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get capacity(): i32 {
    let value = this.get("capacity");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set capacity(value: i32) {
    this.set("capacity", Value.fromI32(value));
  }

  get rarity(): i32 {
    let value = this.get("rarity");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set rarity(value: i32) {
    this.set("rarity", Value.fromI32(value));
  }

  get party(): string | null {
    let value = this.get("party");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set party(value: string | null) {
    if (!value) {
      this.unset("party");
    } else {
      this.set("party", Value.fromString(<string>value));
    }
  }
}

export class Party extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Party entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Party must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Party", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Party | null {
    return changetype<Party | null>(store.get_in_block("Party", id));
  }

  static load(id: string): Party | null {
    return changetype<Party | null>(store.get("Party", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get heroes(): HeroLoader {
    return new HeroLoader("Party", this.get("id")!.toString(), "heroes");
  }

  get relics(): RelicLoader {
    return new RelicLoader("Party", this.get("id")!.toString(), "relics");
  }

  get totalPower(): BigInt {
    let value = this.get("totalPower");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalPower(value: BigInt) {
    this.set("totalPower", Value.fromBigInt(value));
  }

  get totalCapacity(): BigInt {
    let value = this.get("totalCapacity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalCapacity(value: BigInt) {
    this.set("totalCapacity", Value.fromBigInt(value));
  }

  get partyRarity(): i32 {
    let value = this.get("partyRarity");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set partyRarity(value: i32) {
    this.set("partyRarity", Value.fromI32(value));
  }

  get provisionsRemaining(): BigInt {
    let value = this.get("provisionsRemaining");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set provisionsRemaining(value: BigInt) {
    this.set("provisionsRemaining", Value.fromBigInt(value));
  }

  get cooldownEndsAt(): BigInt {
    let value = this.get("cooldownEndsAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set cooldownEndsAt(value: BigInt) {
    this.set("cooldownEndsAt", Value.fromBigInt(value));
  }

  get unclaimedRewards(): BigInt {
    let value = this.get("unclaimedRewards");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set unclaimedRewards(value: BigInt) {
    this.set("unclaimedRewards", Value.fromBigInt(value));
  }

  get fatigueLevel(): i32 {
    let value = this.get("fatigueLevel");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set fatigueLevel(value: i32) {
    this.set("fatigueLevel", Value.fromI32(value));
  }
}

export class PlayerProfile extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlayerProfile entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PlayerProfile must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PlayerProfile", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PlayerProfile | null {
    return changetype<PlayerProfile | null>(
      store.get_in_block("PlayerProfile", id.toHexString()),
    );
  }

  static load(id: Bytes): PlayerProfile | null {
    return changetype<PlayerProfile | null>(
      store.get("PlayerProfile", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get level(): i32 {
    let value = this.get("level");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set level(value: i32) {
    this.set("level", Value.fromI32(value));
  }

  get experience(): BigInt {
    let value = this.get("experience");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set experience(value: BigInt) {
    this.set("experience", Value.fromBigInt(value));
  }
}

export class VIP extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VIP entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type VIP must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VIP", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): VIP | null {
    return changetype<VIP | null>(store.get_in_block("VIP", id.toHexString()));
  }

  static load(id: Bytes): VIP | null {
    return changetype<VIP | null>(store.get("VIP", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get stakedAmount(): BigInt {
    let value = this.get("stakedAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set stakedAmount(value: BigInt) {
    this.set("stakedAmount", Value.fromBigInt(value));
  }

  get tokenId(): BigInt | null {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt | null) {
    if (!value) {
      this.unset("tokenId");
    } else {
      this.set("tokenId", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class PlayerVault extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlayerVault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PlayerVault must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PlayerVault", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PlayerVault | null {
    return changetype<PlayerVault | null>(
      store.get_in_block("PlayerVault", id.toHexString()),
    );
  }

  static load(id: Bytes): PlayerVault | null {
    return changetype<PlayerVault | null>(
      store.get("PlayerVault", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get withdrawableBalance(): BigInt {
    let value = this.get("withdrawableBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set withdrawableBalance(value: BigInt) {
    this.set("withdrawableBalance", Value.fromBigInt(value));
  }

  get totalCommissionPaid(): BigInt {
    let value = this.get("totalCommissionPaid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalCommissionPaid(value: BigInt) {
    this.set("totalCommissionPaid", Value.fromBigInt(value));
  }
}

export class HeroLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Hero[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Hero[]>(value);
  }
}

export class RelicLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Relic[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Relic[]>(value);
  }
}

export class PartyLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Party[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Party[]>(value);
  }
}
