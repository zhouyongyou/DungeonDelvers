# 合約購買儲備流程分析報告

## 項目概述
這是一個基於以太坊的區塊鏈遊戲項目，包含地牢探險、英雄、遺物、隊伍等元素。玩家可以購買儲備物資進行地牢探險。

## 購買儲備主要流程

### 核心函數：`DungeonMaster.buyProvisions()`

```solidity
function buyProvisions(uint256 _partyId, uint256 _amount) 
    external nonReentrant whenNotPaused onlyPartyOwner(_partyId)
{
    require(_amount > 0, "DM: Amount must be > 0");
    require(address(dungeonCore) != address(0), "DM: DungeonCore not set");

    IPlayerVault playerVault = IPlayerVault(dungeonCore.playerVault());
    
    uint256 totalCostUSD = provisionPriceUSD * _amount;
    uint256 requiredSoulShard = dungeonCore.getSoulShardAmountForUSD(totalCostUSD);
    
    playerVault.spendForGame(msg.sender, requiredSoulShard);
    
    IDungeonStorage.PartyStatus memory status = dungeonStorage.getPartyStatus(_partyId);
    status.provisionsRemaining += _amount;
    dungeonStorage.setPartyStatus(_partyId, status);

    emit ProvisionsBought(_partyId, _amount, requiredSoulShard);
}
```

### 完整流程步驟

1. **權限驗證**
   - 檢查調用者是否為隊伍的擁有者
   - 檢查合約是否暫停
   - 防重入攻擊檢查

2. **輸入參數驗證**
   - 驗證購買數量大於0
   - 檢查DungeonCore合約地址已設置

3. **價格計算**
   - 計算總USD成本：`totalCostUSD = provisionPriceUSD * _amount`
   - 通過Oracle轉換為SoulShard代幣數量：`requiredSoulShard = dungeonCore.getSoulShardAmountForUSD(totalCostUSD)`

4. **資金扣除**
   - 從PlayerVault扣除相應的SoulShard代幣
   - 通過`playerVault.spendForGame(msg.sender, requiredSoulShard)`執行

5. **狀態更新**
   - 增加隊伍的剩餘儲備數量
   - 更新DungeonStorage中的隊伍狀態

6. **事件發射**
   - 發出ProvisionsBought事件記錄交易

## 潛在錯誤原因分析

### 1. 權限相關錯誤
**錯誤訊息：** `"DM: Not party owner"`
- **原因：** 調用者不是指定隊伍的擁有者
- **解決方案：** 確保使用正確的錢包地址，該地址擁有對應的Party NFT

### 2. 合約狀態錯誤
**錯誤訊息：** `"DM: DungeonCore not set"`
- **原因：** DungeonCore合約地址未正確設置
- **解決方案：** 管理員需要調用`setDungeonCore()`設置正確地址

### 3. 資金不足錯誤
**錯誤訊息：** `"Vault: Insufficient balance for game spending"`
- **原因：** PlayerVault中SoulShard餘額不足
- **解決方案：** 先充值足夠的SoulShard到PlayerVault

### 4. 價格轉換錯誤
**錯誤訊息：** `"Oracle not set"` 或 `"Oracle: ZERO_PRICE"`
- **原因：** 
  - Oracle合約未設置
  - Uniswap價格池出現問題
  - TWAP週期設置不當
- **解決方案：** 檢查Oracle設置和Uniswap價格池狀態

### 5. 合約暫停錯誤
**錯誤訊息：** `"Pausable: paused"`
- **原因：** DungeonMaster合約已被管理員暫停
- **解決方案：** 等待管理員恢復合約運行

### 6. 重入攻擊保護錯誤
**錯誤訊息：** `"ReentrancyGuard: reentrant call"`
- **原因：** 同一筆交易中重複調用函數
- **解決方案：** 等待上一筆交易完成後再次嘗試

## 關鍵系統依賴分析

### 1. 價格Oracle系統
```solidity
// DungeonCore.getSoulShardAmountForUSD() 依賴：
function getSoulShardAmountForUSD(uint256 _amountUSD) external view returns (uint256) {
    require(oracleAddress != address(0), "Oracle not set");
    uint256 scaledAmount = (_amountUSD * (10**usdDecimals)) / 1e18;
    return IOracle(oracleAddress).getAmountOut(usdTokenAddress, scaledAmount);
}
```
**潛在問題：** 
- Oracle價格異常波動
- Uniswap流動性不足
- TWAP週期設置問題

### 2. PlayerVault資金管理
```solidity
function spendForGame(address _player, uint256 _amount) external onlyAuthorizedGameContracts {
    PlayerInfo storage player = playerInfo[_player];
    require(player.withdrawableBalance >= _amount, "Vault: Insufficient balance for game spending");
    player.withdrawableBalance -= _amount;
    soulShardToken.safeTransfer(msg.sender, _amount);
    emit GameSpending(_player, msg.sender, _amount);
}
```
**潛在問題：**
- 玩家餘額不足
- 代幣轉移失敗
- 權限驗證失敗

## 建議的錯誤處理和預防措施

### 1. 前端預檢查
```javascript
// 建議在前端實施的檢查
async function preCheckBuyProvisions(partyId, amount) {
    // 檢查是否為隊伍擁有者
    const owner = await partyContract.ownerOf(partyId);
    if (owner !== userAddress) {
        throw new Error("您不是此隊伍的擁有者");
    }
    
    // 檢查合約是否暫停
    const isPaused = await dungeonMaster.paused();
    if (isPaused) {
        throw new Error("合約目前暫停中，請稍後再試");
    }
    
    // 檢查餘額是否足夠
    const cost = await calculateProvisionCost(amount);
    const balance = await playerVault.playerInfo(userAddress);
    if (balance.withdrawableBalance < cost) {
        throw new Error("SoulShard餘額不足，請先充值");
    }
}
```

### 2. 分階段執行
建議將購買流程分為多個步驟，提供更好的用戶體驗：
1. 預估成本並顯示給用戶
2. 確認用戶餘額
3. 執行購買交易
4. 確認交易狀態

### 3. 緊急處理機制
- 實施電路熔斷機制，在Oracle價格異常時暫停交易
- 添加最大單次購買限制
- 實施滑點保護

## 監控和日誌

### 重要事件監控
```solidity
event ProvisionsBought(uint256 indexed partyId, uint256 amount, uint256 cost);
event GameSpending(address indexed player, address indexed spender, uint256 amount);
```

### 建議添加的監控指標
- Oracle價格波動監控
- 大額交易預警
- 合約餘額監控
- 失敗交易統計

## 總結

購買儲備功能的主要風險點在於：
1. **價格Oracle的穩定性** - 建議實施多價格源和異常檢測
2. **資金安全** - 確保PlayerVault有足夠的安全措施
3. **系統整體性** - 各合約間的依賴關係需要仔細管理

建議定期進行安全審計，並實施完善的測試覆蓋，特別關注邊界條件和異常情況的處理。