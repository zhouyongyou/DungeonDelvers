# 前端、子圖、伺服器一致性分析報告

## 🔍 概覽
本報告詳細分析了 Dungeon Delvers 專案中前端、子圖、伺服器三個組件之間的數據流和配置一致性，發現了多個關鍵的不吻合問題。

## ❌ 發現的主要問題

### 1. 環境變數不一致 (Critical)
**問題描述**: GraphQL API URL 的環境變數命名不統一

**具體問題**:
- **前端 Apollo 客戶端** (`src/apolloClient.ts`): 使用 `VITE_THE_GRAPH_API_URL`
- **前端其他頁面**: 使用 `VITE_THE_GRAPH_STUDIO_API_URL` 
- **伺服器**: 使用 `VITE_THE_GRAPH_STUDIO_API_URL`

**影響**: 可能導致前端 Apollo 客戶端無法正確連接到 The Graph API

**修復建議**: 統一使用 `VITE_THE_GRAPH_STUDIO_API_URL`

### 2. 合約地址配置不一致 (High)
**問題描述**: 子圖配置文件中的合約地址是硬編碼的，與前端/伺服器的環境變數方式不同

**子圖配置** (`DDgraphql/dungeon-delvers/subgraph.yaml`):
```yaml
Hero: "0x347752f8166D270EDE722C3F31A10584bC2867b3"
Relic: "0x06994Fb1eC1Ba0238d8CA9539dAbdbEF090A5b53"
Party: "0x4F4796b04e3BD3E8d5B447e32944d8B04eF53EB2"
PlayerProfile: "0xE51ae47bf0f9958a0b35f1830675d88C2c7F5232"
VIPStaking: "0x8A9943Bb231eC9131d750c7bcf8A4Ae36bd4f0F8"
```

**前端/伺服器**: 使用環境變數如 `VITE_MAINNET_HERO_ADDRESS`

**影響**: 如果合約地址發生變更，需要同時更新三個地方

### 3. API 端點調用模式差異 (Low)
**問題描述**: 前端和伺服器採用不同的數據獲取策略

**伺服器提供的 API 端點**:
```javascript
app.get('/api/hero/:tokenId', ...)          // NFT metadata
app.get('/api/relic/:tokenId', ...)         // NFT metadata  
app.get('/api/party/:tokenId', ...)         // NFT metadata
app.get('/api/playerprofile/:tokenId', ...) // NFT metadata
app.get('/api/vipstaking/:tokenId', ...)    // NFT metadata
```

**前端數據獲取方式**:
- 主要通過 The Graph GraphQL API 獲取結構化數據
- 通過智能合約的 `tokenURI` 調用獲取 NFT metadata
- 不直接調用 metadata server 的 REST API

**影響**: 
- 伺服器主要為錢包和外部服務提供標準 NFT metadata
- 前端採用更高效的 GraphQL + 鏈上調用方式
- 兩種方式可以並存，服務不同用途

### 4. GraphQL 查詢結構差異 (Medium)
**問題描述**: 前端和伺服器使用不同的 GraphQL 查詢結構

**前端查詢** (`src/api/nfts.ts`):
```graphql
query GetPlayerAssets($owner: ID!) {
  player(id: $owner) {
    heroes { id tokenId power rarity }
    relics { id tokenId capacity rarity }
    parties { id tokenId totalPower totalCapacity partyRarity heroes { tokenId } relics { tokenId } }
    vip { id tokenId stakedAmount }
  }
}
```

**伺服器查詢** (`dungeon-delvers-metadata-server/src/index.js`):
```graphql
query GetHero($id: ID!) { hero(id: $id) { rarity power } }
query GetRelic($id: ID!) { relic(id: $id) { rarity capacity } }
```

**影響**: 查詢效率和數據獲取方式不同

### 5. 數據類型和 ID 格式 ✅ (已確認一致)
**問題描述**: 經過檢查，ID 格式在所有組件中是一致的

**統一的 ID 格式**:
```typescript
// 所有組件都使用: contractAddress.toLowerCase() + "-" + tokenId
```

**子圖**: `createEntityId(contractAddress, tokenId)` 函數統一處理
**前端**: `${contractAddress.toLowerCase()}-${tokenId}`
**伺服器**: `${contractAddresses.hero.toLowerCase()}-${tokenId}`

**狀態**: ✅ 一致，無需修復

### 6. VIP 數據結構不匹配 (Medium)
**問題描述**: VIP 相關的數據結構在不同組件中定義不同

**子圖 Schema**:
```graphql
type VIP {
  player: Player!
  tokenId: BigInt!
  stakedAmount: BigInt!
  level: Int!
}
```

**前端類型**:
```typescript
interface VipNft extends BaseNft {
  type: 'vip';
  level: number;
}
```

**影響**: 可能導致數據獲取和顯示問題

## ✅ 確認正確的部分

### 1. 基本數據模型一致性
- Hero, Relic, Party 的核心屬性在三個組件中基本一致
- 稀有度、戰力、容量等關鍵數據類型匹配

### 2. 事件處理邏輯
- 子圖正確監聽智能合約事件
- 數據更新邏輯合理

### 3. SVG 生成邏輯
- 伺服器的 SVG 生成邏輯完整且功能豐富

## 🔧 修復建議

### 立即需要修復 (Critical/High)
1. **統一環境變數命名**
   - 將所有 `VITE_THE_GRAPH_API_URL` 改為 `VITE_THE_GRAPH_STUDIO_API_URL`
   
2. **同步合約地址**
   - 驗證子圖配置中的硬編碼地址與環境變數是否一致
   - 考慮使用配置管理工具統一管理

### 中期優化 (Medium)
3. **統一查詢策略**
   - 標準化 GraphQL 查詢格式
   - 優化數據獲取效率

4. **驗證 API 端點**
   - 確保前端正確調用伺服器 API 端點
   - 添加端點文檔

5. **標準化 ID 格式**
   - 確保所有組件使用相同的實體 ID 生成邏輯

### 長期改進 (Low)
6. **添加一致性測試**
   - 創建自動化測試確保三個組件的數據一致性
   - 添加類型檢查

7. **配置集中化**
   - 考慮使用共享配置文件管理所有地址和設定

## 🚀 建議的修復順序
1. **立即修復** - 環境變數不一致問題
2. **高優先級** - 驗證並同步合約地址
3. **中優先級** - 統一 GraphQL 查詢策略
4. **低優先級** - 優化數據獲取效率
5. **長期規劃** - 實施配置集中化和自動化測試

## ⚡ 立即需要執行的修復步驟

### 步驟 1: 修復環境變數不一致
```bash
# 在前端項目中統一使用 VITE_THE_GRAPH_STUDIO_API_URL
# 修改 src/apolloClient.ts
const THE_GRAPH_API_URL = import.meta.env.VITE_THE_GRAPH_STUDIO_API_URL;
```

### 步驟 2: 驗證合約地址一致性
需要確認以下地址在所有組件中是否一致：
- Hero: `0x347752f8166D270EDE722C3F31A10584bC2867b3`
- Relic: `0x06994Fb1eC1Ba0238d8CA9539dAbdbEF090A5b53`
- Party: `0x4F4796b04e3BD3E8d5B447e32944d8B04eF53EB2`
- PlayerProfile: `0xE51ae47bf0f9958a0b35f1830675d88C2c7F5232`
- VIPStaking: `0x8A9943Bb231eC9131d750c7bcf8A4Ae36bd4f0F8`

## 📊 風險評估
- **高風險**: 環境變數不一致可能導致服務完全無法工作
- **中風險**: 數據結構差異可能導致部分功能異常  
- **低風險**: 查詢效率問題影響性能但不影響功能

## 📋 總結

### 🎯 核心發現
通過詳細分析，發現的主要問題集中在：
1. **環境變數命名不一致** - 這是最關鍵的問題
2. **合約地址管理方式不同** - 需要建立統一的配置管理
3. **數據獲取策略差異** - 前端和伺服器採用不同方法，但這是合理的架構設計

### ✅ 已確認正常的部分  
1. **ID 格式一致性** - 所有組件使用相同的 ID 生成邏輯
2. **核心數據模型** - Hero, Relic, Party 的基本屬性保持一致
3. **事件處理邏輯** - 子圖正確監聽和處理智能合約事件

### 🔧 建議優先級
- **Critical**: 修復 Apollo 客戶端的環境變數問題
- **High**: 驗證所有合約地址的一致性
- **Medium**: 改進 GraphQL 查詢策略
- **Low**: 優化整體架構設計

這個分析顯示了一個相對健康的架構，主要需要修復的是配置管理方面的問題。