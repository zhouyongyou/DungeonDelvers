import { createConfig, http } from 'wagmi';
import { bsc, bscTestnet, hardhat } from 'wagmi/chains';
import { coinbaseWallet, injected, walletConnect } from 'wagmi/connectors';
import { createSmartRpcTransport } from './smartRpcTransport';
import { logger } from '../utils/logger';

// åˆ¤æ–·æ˜¯å¦ç‚ºå¯«å…¥æ“ä½œï¼ˆéœ€è¦ç°½åçš„äº¤æ˜“ï¼‰
function isWriteOperation(method: string): boolean {
  const writeMethods = [
    'eth_sendTransaction',
    'eth_sendRawTransaction',
    'eth_sign',
    'eth_signTransaction',
    'eth_signTypedData',
    'eth_signTypedData_v3',
    'eth_signTypedData_v4',
    'personal_sign'
  ];
  return writeMethods.includes(method);
}

// å‰µå»ºæ··åˆ RPC transport
function createHybridTransport() {
  // ç²å–æˆ‘å€‘çš„æŸ¥è©¢ç”¨ transport
  const queryTransport = createSmartRpcTransport();
  
  // è¿”å›ä¸€å€‹æ··åˆ transport
  return (config: any) => {
    return {
      ...http()(config),
      request: async ({ method, params }: any) => {
        // å¦‚æœæ˜¯å¯«å…¥æ“ä½œæˆ– gas ä¼°ç®—ï¼Œä½¿ç”¨ç”¨æˆ¶çš„ MetaMask RPC
        if (isWriteOperation(method) || method === 'eth_estimateGas' || method === 'eth_gasPrice') {
          logger.info(`ğŸ¦Š ä½¿ç”¨ MetaMask RPC: ${method}`);
          
          // ç›´æ¥ä½¿ç”¨ window.ethereum
          if (window.ethereum && window.ethereum.request) {
            try {
              return await window.ethereum.request({ method, params });
            } catch (error) {
              logger.error('MetaMask RPC éŒ¯èª¤:', error);
              throw error;
            }
          } else {
            throw new Error('MetaMask not available');
          }
        }
        
        // å…¶ä»–æŸ¥è©¢æ“ä½œä½¿ç”¨æˆ‘å€‘çš„ RPC
        logger.debug(`ğŸ” ä½¿ç”¨æŸ¥è©¢ RPC: ${method}`);
        return queryTransport(config).request({ method, params });
      }
    };
  };
}

// ç²å–æ”¯æŒçš„éˆ
function getSupportedChains() {
  const isDevelopment = import.meta.env.DEV;
  
  if (isDevelopment) {
    return [bsc, bscTestnet, hardhat] as const;
  }
  
  return [bsc] as const;
}

// å‰µå»º transports é…ç½®
function createTransports() {
  const isDevelopment = import.meta.env.DEV;
  const hybridTransport = createHybridTransport();
  
  const transports: any = {
    [bsc.id]: hybridTransport,
  };
  
  if (isDevelopment) {
    transports[bscTestnet.id] = hybridTransport;
    transports[hardhat.id] = http();
  }
  
  return transports;
}

// WalletConnect projectId
const walletConnectProjectId = import.meta.env.VITE_WALLET_CONNECT_PROJECT_ID || '';

if (!walletConnectProjectId) {
  logger.warn('âš ï¸ WalletConnect Project ID æœªè¨­ç½®');
}

// å‰µå»º wagmi é…ç½®
export const config = createConfig({
  chains: getSupportedChains(),
  transports: createTransports(),
  connectors: [
    injected({
      shimDisconnect: true,
      target() {
        return {
          id: 'metaMask',
          name: 'MetaMask',
          provider: window.ethereum,
        };
      },
    }),
    walletConnect({
      projectId: walletConnectProjectId,
      showQrModal: true,
      qrModalOptions: {
        themeMode: 'dark',
      },
    }),
    coinbaseWallet({
      appName: 'Dungeon Delvers',
      darkMode: true,
    }),
  ],
  ssr: false,
});

// å°å‡ºéˆé…ç½®
export const supportedChains = getSupportedChains();
export const defaultChain = bsc;

// é¡å‹è²æ˜
declare global {
  interface Window {
    ethereum?: any;
  }
}