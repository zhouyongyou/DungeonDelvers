// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {VRFV2PlusWrapperConsumerBase} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "../interfaces/IHero.sol";
import "../interfaces/IRelic.sol";

contract AltarOfAscension is Ownable, ReentrancyGuard, Pausable, VRFV2PlusWrapperConsumerBase {

    IHero public heroContract;
    IRelic public relicContract;

    struct UpgradeRule {
        uint8 materialsRequired;
        uint256 nativeFee;
        uint8 greatSuccessChance;
        uint8 successChance;
        uint8 partialFailChance;
    }
    mapping(uint8 => UpgradeRule) public upgradeRules;

    struct UpgradeRequest {
        address player;
        address tokenContract;
        uint8 baseRarity;
    }
    mapping(uint256 => UpgradeRequest) public s_requests;

    uint32 private constant CALLBACK_GAS_LIMIT = 500000;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUM_WORDS = 1;

    event UpgradeRequested(uint256 indexed requestId, address indexed player, address indexed tokenContract, uint256[] tokenIds);
    event UpgradeFulfilled(uint256 indexed requestId, address indexed player, uint8 outcome, uint256[] newTokens);
    event UpgradeRuleSet(uint8 indexed fromRarity, UpgradeRule rule);
    
    constructor(
        address _vrfWrapper,
        address _heroContractAddress,
        address _relicContractAddress
    ) VRFV2PlusWrapperConsumerBase(_vrfWrapper) Ownable(msg.sender) {
        heroContract = IHero(_heroContractAddress);
        relicContract = IRelic(_relicContractAddress);

        upgradeRules[1] = UpgradeRule({ materialsRequired: 5, nativeFee: 0.005 ether, greatSuccessChance: 5, successChance: 65, partialFailChance: 28 });
        emit UpgradeRuleSet(1, upgradeRules[1]);
        upgradeRules[2] = UpgradeRule({ materialsRequired: 4, nativeFee: 0.01 ether, greatSuccessChance: 4, successChance: 51, partialFailChance: 35 });
        emit UpgradeRuleSet(2, upgradeRules[2]);
        upgradeRules[3] = UpgradeRule({ materialsRequired: 3, nativeFee: 0.02 ether, greatSuccessChance: 3, successChance: 32, partialFailChance: 45 });
        emit UpgradeRuleSet(3, upgradeRules[3]);
        upgradeRules[4] = UpgradeRule({ materialsRequired: 2, nativeFee: 0.05 ether, greatSuccessChance: 2, successChance: 18, partialFailChance: 50 });
        emit UpgradeRuleSet(4, upgradeRules[4]);
    }

    function upgradeNFTs(address _tokenContract, uint256[] calldata _tokenIds) 
        external 
        payable 
        whenNotPaused 
        nonReentrant 
    {
        uint8 baseRarity = _validateAndBurnMaterials(_tokenContract, _tokenIds);
        UpgradeRule memory rule = upgradeRules[baseRarity];
        require(rule.materialsRequired > 0, "Altar: Upgrades for this rarity are not configured");
        require(msg.value >= rule.nativeFee, "Altar: Insufficient BNB fee");
        
        bytes memory extraArgs = VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: true}));
        (uint256 requestId, ) = requestRandomnessPayInNative(CALLBACK_GAS_LIMIT, REQUEST_CONFIRMATIONS, NUM_WORDS, extraArgs);

        s_requests[requestId] = UpgradeRequest({
            player: msg.sender,
            tokenContract: _tokenContract,
            baseRarity: baseRarity
        });
        
        emit UpgradeRequested(requestId, msg.sender, _tokenContract, _tokenIds);
    }
    
    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        UpgradeRequest storage request = s_requests[_requestId];
        require(request.player != address(0), "Altar: Invalid request");

        uint256 randomValue = _randomWords[0];
        uint256 chanceRoll = randomValue % 100;
        UpgradeRule memory rule = upgradeRules[request.baseRarity];
        uint8 outcome;
        uint256[] memory newTokens = new uint256[](2); // 最多只會產出兩個

        if (chanceRoll < rule.greatSuccessChance) { // 大成功
            newTokens[0] = _mintUpgradedNFT(request.player, request.tokenContract, request.baseRarity + 1, randomValue);
            newTokens[1] = _mintUpgradedNFT(request.player, request.tokenContract, request.baseRarity + 1, randomValue >> 32); // 用不同的隨機數
            outcome = 3;
        } else if (chanceRoll < rule.greatSuccessChance + rule.successChance) { // 成功
            newTokens[0] = _mintUpgradedNFT(request.player, request.tokenContract, request.baseRarity + 1, randomValue);
            outcome = 2;
        } else if (chanceRoll < rule.greatSuccessChance + rule.successChance + rule.partialFailChance) { // 部分失敗
            uint256 materialsToReturn = rule.materialsRequired / 2;
            for (uint i = 0; i < materialsToReturn; i++) {
                 _mintUpgradedNFT(request.player, request.tokenContract, request.baseRarity, randomValue + i); // 加上i來避免產生完全一樣的
            }
            outcome = 1;
        } else { // 徹底失敗
            outcome = 0;
        }

        emit UpgradeFulfilled(_requestId, request.player, outcome, newTokens);
        delete s_requests[_requestId];
    }

    function _validateAndBurnMaterials(address _tokenContract, uint256[] calldata _tokenIds) internal returns (uint8 baseRarity) {
        require(_tokenIds.length > 0, "Altar: No materials provided");
        if (_tokenContract == address(heroContract)) {
            (baseRarity,) = IHero(_tokenContract).getHeroProperties(_tokenIds[0]);
        } else if (_tokenContract == address(relicContract)) {
            (baseRarity,) = IRelic(_tokenContract).getRelicProperties(_tokenIds[0]);
        } else {
            revert("Altar: Invalid token contract");
        }
        require(baseRarity > 0 && baseRarity < 5, "Altar: Invalid rarity for upgrade");
        require(_tokenIds.length == upgradeRules[baseRarity].materialsRequired, "Altar: Incorrect number of materials");
        
        for (uint i = 0; i < _tokenIds.length; i++) {
            if (_tokenContract == address(heroContract)) {
                require(IHero(_tokenContract).ownerOf(_tokenIds[i]) == msg.sender, "Altar: Not owner of all materials");
                (uint8 rarity,) = IHero(_tokenContract).getHeroProperties(_tokenIds[i]);
                require(rarity == baseRarity, "Altar: Materials must have same rarity");
                IHero(_tokenContract).burnFromAltar(_tokenIds[i]);
            } else {
                require(IRelic(_tokenContract).ownerOf(_tokenIds[i]) == msg.sender, "Altar: Not owner of all materials");
                (uint8 rarity,) = IRelic(_tokenContract).getRelicProperties(_tokenIds[i]);
                require(rarity == baseRarity, "Altar: Materials must have same rarity");
                IRelic(_tokenContract).burnFromAltar(_tokenIds[i]);
            }
        }
    }

    function _mintUpgradedNFT(address _player, address _tokenContract, uint8 _rarity, uint256 _randomNumber) private returns (uint256) {
        if (_tokenContract == address(heroContract)) {
            return IHero(_tokenContract).mintFromAltar(_player, _rarity, _randomNumber);
        } else {
            return IRelic(_tokenContract).mintFromAltar(_player, _rarity, _randomNumber);
        }
    }
    
    function setUpgradeRule(uint8 _fromRarity, UpgradeRule calldata _rule) external onlyOwner {
        require(_fromRarity > 0 && _fromRarity < 5, "Invalid fromRarity");
        require(_rule.greatSuccessChance + _rule.successChance + _rule.partialFailChance < 100, "Altar: Total chance must be less than 100");
        upgradeRules[_fromRarity] = _rule;
        emit UpgradeRuleSet(_fromRarity, _rule);
    }
    
    function setHeroContract(address _address) external onlyOwner { heroContract = IHero(_address); }
    function setRelicContract(address _address) external onlyOwner { relicContract = IRelic(_address); }

    function withdrawNative() external onlyOwner {
        (bool success, ) = owner().call{value: address(this).balance}("");
        require(success, "Withdraw failed");
    }

    function pause() public onlyOwner { _pause(); }
    function unpause() public onlyOwner { _unpause(); }
}
